--{{{  all sorts of #'s
#OPTION "E V" -- no compiler libraries, no vector space
#COMMENT "Type conversion library V1.4 4/12/90"
#COMMENT "(c) Copyright INMOS Limited 1988, 1990"
#PRAGMA TRANSLATE QRealIMul "QRealIMul%CHK"
#PRAGMA TRANSLATE QRealIDiv "QRealIDiv%CHK"
#PRAGMA TRANSLATE QUADNORMALISE "QUADNORMALISE%CHK"
#PRAGMA TRANSLATE QUADSHIFTLEFT "QUADSHIFTLEFT%CHK"
#USE "occamutl.lib"
--}}}
PROC REAL64TOSTRING (INT len, []BYTE string, VAL REAL64 X, VAL INT Ip, Dp)

  --{{{  specification
  -- Purpose:  To take a binary representation of a real number and convert
  --           it into a string of characters that is the decimal
  --           representation of that number, formatted according to given
  --           rules ( see Notes below ).
  -- Out:      len - the number of characters ( BYTEs ) of string occupied
  --           by the formatted decimal representation of the real number
  -- Out:      string - an array containing the formatted decimal
  --           representation of the real number in the first len bytes,
  --           the remaining bytes being undefined
  -- In:       X - the real number, in IEEE format, to be converted
  -- In:       Ip - the first of two formatting values
  -- In:       Dp - the second of two formatting values
  --{{{  Notes
  -- Notes:    Rounding mode is round to nearest.
  --           Which format is used depends on the combination of values
  --           of Ip, Dp and X.  In all cases, any digits beyond the 9th
  --           significant digit for single precision or 17th significant
  --           digit for double precision will be given as 0 and cannot
  --           be considered accurate.
  --           If string overflows this routine acts as an invalid process.
  --{{{  Case i
  -- Case (i):    Ip = 0, Dp = 0  => free format
  --           Where possible a fixed point representation is used.  If
  --           it is not used then exponential form is used.  It is not
  --           used if more than 9 | 17 significant digits of accuracy
  --           ( single | double ) would be required before the decimal
  --           point, or if there are more than 3 zeroes after the decimal
  --           point before the first significant digit.  In any case, the
  --           maximum number of characters returned in string is 15 for a
  --           single precision X, and 24 for a double precision X.
  --           string is left justified.
  --           If X is infinity or a NaN, then the string will contain one
  --           of "Inf", "-Inf" or "NaN", but not the quotes.
  --}}}
  --{{{  Case ii
  -- Case (ii):   Ip = 0, Dp > 0  => exponential format
  --           The form of exponential format is, firstly either a minus
  --           sign or a space ( this latter instead of an explicit plus
  --           sign ), a fraction in the form <digit>.<digits>, the
  --           exponential symbol ( E ), the sign of the exponent ( + or
  --           - ), then the exponent, which is two digits for a single
  --           precision X, three digits for a double precision X.  Dp
  --           gives the number of digits in the fraction ( 1 before the
  --           point, and the others after, but not counting the point ).
  --           The total number of characters in string is ( Dp + 6 )
  --           for a single precision X, and ( Dp + 7 ) for a double
  --           precision X.
  --           If Dp = 1 then the fraction is of the form <space>digit
  --           ( which, note, will not result in occam syntax for the
  --           real ).
  --           If X is infinity or a NaN, then the string will contain one
  --           of " Inf", "-Inf" or " NaN", but not the quotes, padded on
  --           the right to fill the field width.
  --}}}
  --{{{  Case iii
  -- Case (iii):  Ip > 0, Dp > 0  => fixed point if possible
  --           Ip gives the number of places before the point, not
  --           counting the sign place; Dp the number of places after
  --           the point.  Padding spaces are added on the left as
  --           necessary.  If the number will not fit the format,
  --           then an exponential format is used with the same field
  --           width as the fixed point representation would have had.
  --           If Ip and Dp are very small then an exponential
  --           representation may not fit in the field width so the
  --           special value "Ov" with a sign is returned.
  --           There are always ( Ip + Dp + 2 ) characters in string,
  --           the 2 being the decimal point and the sign ( - or space ).
  --           If X is infinity or a NaN, then the string will contain one
  --           of " Inf", "-Inf" or " NaN", but not the quotes, padded on
  --           the right to fill the field width.
  --}}}
  -- All other combinations of Ip and Dp are meaningless and will cause
  --           an error.
  --}}}
  --}}}
  --{{{  history
  -- V1.0, 1-Jul-99
  -- Added V to the OPTIONs; V1.1, 22-Mar-90 SRH
  -- Formatting completely revamped; bug report number TS/37; V1.2,
  -- 26-Apr-90 SRH
  -- Added more comments; 5-Oct-90 SRH
  -- Removed redundant bit of code ( that which used to output Un ); also
  -- corrected the rounding of numbers almost midway between two other
  -- numbers - rounding.direction introduced; bug report number TS/789; 
  -- also made various variable name changes to improve readability of
  -- code; V1.3, 28-Nov-90 SRH
  -- Added assignment to zero of Guard in QScaleX when overflow to
  -- infinity; this prevents possible addition of 1 to infinity to
  -- make a NaN; V1.4, 4-Dec-90 SRH
  --}}}
  --{{{  more information
  -- To help understand the binary to character conversion see "Contributions
  -- to a Proposed Standard for Binary Floating-Point Arithmetic" by J T Coonen,
  -- PhD thesis, 1984, University of California, Berkeley.
  --}}}

  VAL []INT X RETYPES X :

  --{{{  Definitions
  --{{{  Word length specific values for 16 bit machine
  VAL SignBit      IS #8000 :
  VAL BitsPerWord  IS    16 :
  VAL MaxInt       IS #FFFF :
  VAL BytesPerWord IS     2 :
  --}}}
  --{{{  IEEE Quad length constants for 16 bit implementation
  VAL QRealShift  IS    11 :
  VAL QBitsInFrac IS    53 :
  VAL QRealExpSh  IS     4 :
  VAL QRealExp    IS  #7FF :
  VAL QRealXcess  IS  1023 :
  VAL QRealRBit   IS  #400 :
  VAL QRealInf    IS #7FF0 :
  --}}}
  --{{{  Quad Read/Write constants
  -- write number constants
  VAL QTable10 IS    27 : --exact power of ten in word
  VAL QBias10  IS     4 : --extras for full power ten range
  VAL QMaxDecN IS    17 : --maximum dec digits; IEEE 754-1985, Sec 5.6
  VAL R2L      IS #4D10 : --Log10(2) = 0.3010299956639811952 in word for QuickLog
  
  -- The table QPowerTenFrac contains the fraction with implicit bit
  -- explicit and then normalized so that there is a one bit in bit 31
  -- of powers of 10 from 10^0 to 10^27.  For example,
  -- 10^3 = 1111101000 in binary, which is 1.111101 * 2^9; so the fraction
  -- bits, with implicit bit explicit ( ie the 1 before the point kept ) is
  -- 1111101, and the actual exponent is 9.  This latter ( the actual
  -- exponent ) is what is in the corresponding table PowerTenExp.
  -- The index of an entry is the same as the power of 10 in
  -- PowerTenExp; hence PowerTenExp[ 3 ] = 9.  For QPowerTenFrac four times
  -- the power of 10 gives the index of the lowest word of the fraction,
  -- the highest word being in the element three after; hence
  -- QPowerTenFrac[ 4 * 3 ] = #0000 and QPowerTenFrac[ 4 * 3 + 3 ] = #FA00.
  -- These two tables of constants are simply set up in advance for
  -- efficiency.
  VAL QPowerTenFrac IS [#0000, #0000, #0000, #8000, #0000, #0000,
   #0000, #A000, #0000, #0000, #0000, #C800, #0000, #0000, #0000,
   #FA00, #0000, #0000, #0000, #9C40, #0000, #0000, #0000, #C350,
   #0000, #0000, #0000, #F424, #0000, #0000, #8000, #9896, #0000,
   #0000, #2000, #BEBC, #0000, #0000, #2800, #EE6B, #0000, #0000,
   #F900, #9502, #0000, #0000, #B740, #BA43, #0000, #0000, #A510,
   #E8D4, #0000, #0000, #E72A, #9184, #0000, #8000, #20F4, #B5E6,
   #0000, #A000, #A931, #E35F, #0000, #0400, #C9BF, #8E1B, #0000,
   #C500, #BC2E, #B1A2, #0000, #7640, #6B3A, #DE0B, #0000, #89E8,
   #2304, #8AC7, #0000, #AC62, #EBC5, #AD78, #8000, #177A, #26B7,
   #D8D7, #9000, #6EAC, #7832, #8786, #B400, #0A57, #163F, #A968,
   #A100, #CCED, #1BCE, #D3C2, #84A0, #4014, #5161, #8459, #A5C8,
   #9019, #A5B9, #A56F, #0F3A, #F420, #8F27, #CECB] :
  
  VAL PowerTenExp IS [0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36,
   39, 43, 46, 49, 53, 56, 59, 63, 66, 69, 73, 76, 79, 83, 86, 89] :
  
  VAL QBiasTenFrac IS [0, 0, 0, 0, #0F3A, #F420, #8F27, #CECB, #0766,
   #CFE2, #4B50, #D0CF, #8DEA, #1A70, #EE64, #DA01, #3E41, #BD20,
   #A169, #9F79] : --P27, P55, P108, P206
  
  VAL BiasTenExp IS [0, 89, 182, 358, 684] :
  
  VAL BiasTen IS [0, 27, 55, 108, 206] :
  --}}}
  --{{{  rounding constants
  VAL INT rounded.down IS -1 :
  VAL INT exact        IS  0 :
  VAL INT rounded.up   IS  1 :
  --}}}
  --}}}
  --{{{  QScaleX
  PROC QScaleX (INT Xexp, [4]INT Xfrac, VAL INT Scale, INT direction)
  
    -- Scale X by value of 10^Scale
  
    INT Carry, Carry1, Carry2, Carry3, Guard, N, Places, S, T, Zexp, dummy :
    [4]INT Zfrac, temp :
    SEQ
      --{{{  get abs value of Scale
      IF
        Scale < 0
          S := -Scale
        TRUE
          S := Scale
      --}}}
      --{{{  set Z to 1
      Zexp := 0
      Zfrac[3] := SignBit
      Zfrac[2] := 0
      Zfrac[1] := 0
      Zfrac[0] := 0
      --}}}
      --{{{  set Zexp and Zfrac - evaluate 10^S
      N := QBias10
      WHILE N >= 0
        IF
          (N > 0) AND (S < BiasTen[N])
            N := N - 1                            --do not need this power
          TRUE
            SEQ
              IF
                (N = 0) AND (S <= QTable10)       --final scale factor
                  SEQ
                    QRealIMul (Zfrac, Guard,
                           QPowerTenFrac[(S << 2) + 3], QPowerTenFrac[(S << 2) + 2],
                           QPowerTenFrac[(S << 2) + 1], QPowerTenFrac[S << 2])
                    Zexp := (Zexp + PowerTenExp[S]) + 1
                TRUE
                  SEQ
                    QRealIMul (Zfrac, Guard,
                           QBiasTenFrac[(N << 2) + 3], QBiasTenFrac[(N << 2) + 2],
                           QBiasTenFrac[(N << 2) + 1], QBiasTenFrac[N << 2])
                    S := S - BiasTen[N]
                    Zexp := (Zexp + BiasTenExp[N]) + 1
              --{{{  renormalise and round Z
              temp := Zfrac
              T := Guard
              QUADNORMALISE (Places, Zfrac, Guard, temp, T)
              Zexp := Zexp - Places
              IF
                (Guard /\ SignBit) = 0            --no need to round up
                  SKIP
                TRUE
                  SEQ
                    --{{{  long arithmetic
                    Carry, Zfrac[0] := LONGSUM (Zfrac[0], 1, 0)
                    Carry, Zfrac[1] := LONGSUM (Zfrac[1], 0, Carry)
                    Carry, Zfrac[2] := LONGSUM (Zfrac[2], 0, Carry)
                    Carry, Zfrac[3] := LONGSUM (Zfrac[3], 0, Carry)
                    --}}}
                    IF
                      Carry = 0
                        SKIP
                      TRUE                        --carry out to exp
                        SEQ
                          Zexp := Zexp + 1
                          Zfrac[3] := SignBit     --"shift" the carry back into Zfrac
              --}}}
              N := N - 1                          --down to next scale
      --}}}
      --{{{  set Xexp, Xfrac and Guard
      IF
        --{{{  check if was in range
        S > QTable10                          --out of range
          SEQ
            IF
              Scale < 0                       --set to big number
                Xexp := -QRealExp
              TRUE
                Xexp := QRealExp
            Xfrac[3] := SignBit               --prevent normalisation
            Xfrac[2] := 0
            Xfrac[1] := 0
            Xfrac[0] := 0
            Guard := 0
        --}}}
        --{{{  scale down - divide X by Z
        Scale < 0                             --scale down
          SEQ
            Xexp := Xexp - Zexp
            dummy, Xfrac[0]    := SHIFTRIGHT (Xfrac[1], Xfrac[0], 1)
            dummy, Xfrac[1]    := SHIFTRIGHT (Xfrac[2], Xfrac[1], 1)
            Xfrac[3], Xfrac[2] := SHIFTRIGHT (Xfrac[3], Xfrac[2], 1)
            --{{{  do divisions
            Xfrac[3], Xfrac[2], Xfrac[1], Xfrac[0], Guard :=
              QRealIDiv (Xfrac[3], Xfrac[2], Xfrac[1], Xfrac[0], 0, Zfrac)
            Xfrac[2], Xfrac[1], Xfrac[0], Guard, Carry1 :=
              QRealIDiv (Xfrac[2], Xfrac[1], Xfrac[0], Guard, 0, Zfrac)
            Xfrac[1], Xfrac[0], Guard, Carry1, Carry2 :=
              QRealIDiv (Xfrac[1], Xfrac[0], Guard, Carry1, 0, Zfrac)
            Xfrac[0], Guard, Carry1, Carry2, Carry3 :=
              QRealIDiv (Xfrac[0], Guard, Carry1, Carry2, 0, Zfrac)
            --}}}
            -- original code ( V1.2 ) to assign Guard:
            ---- now see if over half left
            --dummy, Zfrac[0]    := SHIFTRIGHT (Zfrac[1], Zfrac[0], 1)
            --dummy, Zfrac[1]    := SHIFTRIGHT (Zfrac[2], Zfrac[1], 1)
            --Zfrac[3], Zfrac[2] := SHIFTRIGHT (Zfrac[3], Zfrac[2], 1)
            --INT Borrow :
            --SEQ
            --  Borrow, dummy := LONGDIFF (Carry3, Zfrac[0], 0)
            --  Borrow, dummy := LONGDIFF (Carry2, Zfrac[1], Borrow)
            --  Borrow, dummy := LONGDIFF (Carry1, Zfrac[2], Borrow)
            --  Borrow, dummy := LONGDIFF (Guard, Zfrac[3], Borrow)
            --  IF
            --    Borrow = 0                       --over half left
            --      Guard := SignBit
            --    TRUE
            --      Guard := 0
            --{{{  obtain more accurate value of Guard ( V1.3 ) - matters in assignment of direction
            IF
              ( Guard = 0 ) AND ( Carry1 = 0 ) AND ( Carry2 = 0 ) AND ( Carry3 = 0 )
                SKIP                               --divided exactly
              TRUE
                INT Rem.hi, Rem.mid, Rem.lo :
                Guard, Rem.hi, Rem.mid, Rem.lo, dummy :=
                  QRealIDiv( Guard, Carry1, Carry2, Carry3, 0, Zfrac )
                --Guard is not zero now if this branch of the IF taken
            --}}}
        --}}}
        --{{{  scale up - multiply X by Z
        TRUE                                  --scale up
          SEQ
            Xexp := (Xexp + Zexp) + 1
            QRealIMul (Xfrac, Guard, Zfrac[3], Zfrac[2], Zfrac[1], Zfrac[0])
        --}}}
      --}}}
      --{{{  normalise
      temp := Xfrac
      T := Guard
      QUADNORMALISE (Places, Xfrac, Guard, temp, T)
      Xexp := Xexp - Places
      --}}}
      --{{{  round and set direction
      IF
        Guard = 0
          direction := exact
        (Guard /\ SignBit) = 0
          direction := rounded.down
        TRUE
          SEQ
            direction := rounded.up
            --{{{  long arithmetic
            Carry, Xfrac[0] := LONGSUM (Xfrac[0], 1, 0)
            Carry, Xfrac[1] := LONGSUM (Xfrac[1], 0, Carry)
            Carry, Xfrac[2] := LONGSUM (Xfrac[2], 0, Carry)
            Carry, Xfrac[3] := LONGSUM (Xfrac[3], 0, Carry)
            --}}}
            IF
              Carry <> 0
                SEQ
                  Xexp := Xexp + 1
                  Xfrac[3] := SignBit
              TRUE                            --no overflow to exp
                SKIP
      --}}}
  :
  --}}}
  --{{{  QuickLog
  PROC QuickLog (INT LogX, VAL INT Xexp, VAL [4]INT Xfrac)
  
    -- Purpose: To be a cheap approximation of floor( Log10( X ) ), so
    --          cheap that it may be 1 too small.
    -- Out:     LogX - either floor( log10( X ) ) or floor( log10( X ) ) - 1
    -- In:      Xexp - actual exponent, i.e. biased exponent - RealXcess
    -- In:      Xfrac - fractional part with the implicit bit explicit
    --          ( and normalised if from a denormal ) so that bit 31
    --          is 1
    -- Notes:   If Xexp = 0 = Xfrac, then LogX is returned as 0.
  
    INT X, Y :
    SEQ
      -- Use approximation of Log2( 1.f * 2^e ) as e.f, due to
      -- 0.f <= log2( 1.f ), with a maximum deviation of about 0.086
      X := Xexp
      Y := Xfrac[3] << 1
      IF
        X < 0                                     --log2 may be small
          INT Carry, Borrow :
          SEQ
            --{{{  long arithmetic
            Borrow, Y    := LONGDIFF (0, Y, 0)
            Borrow, X    := LONGDIFF (0, X, Borrow)
            Carry, Y     := LONGPROD (Y, R2L + 1, 0)
            Carry, X     := LONGPROD (X, R2L + 1, Carry)
            Borrow, Y    := LONGDIFF (0, Y, 0)
            Borrow, X    := LONGDIFF (0, X, Borrow)
            Borrow, LogX := LONGDIFF (0, Carry, Borrow)
            --}}}
        TRUE                                      --log2 about right
          INT Carry, dummy :
          SEQ                                     --mul by Log10(2)
            Carry, dummy := LONGPROD (Y, R2L, 0)
            LogX, dummy  := LONGPROD (X, R2L, Carry)
  :
  --}}}
  --{{{  Round
  PROC Round (INT Xexp, [4]INT Xfrac, Xint, INT direction)
  
    --{{{  specification
    -- Purpose: To round a real number to the nearest integer.
    -- In/Out:  Xexp - actual exponent, not biased one: on entry, of the
    --          number to round; on exit, of the rounded number
    -- In/Out:  Xfrac - the fractional part of the real with implicit bit
    --          explicit: on entry, of the number to round; on exit, of the
    --          rounded number
    -- Out:     Xint - the nearest integer that the combination of Xexp
    --          and Xfrac on entry give
    -- In/Out:  direction - this parameter is applicable only for numbers
    --          ending in 5: equal to -1 if the exact value was
    --          rounded down; equal to 0 if the value on entry is
    --          exact; equal to +1 if the exact value was rounded up
    -- Notes:   ( Xexp on entry ) < ( 4 * the number of bits per word ) is
    --          assumed.
    --          This procedure only caters for non-negative numbers.
    --}}}
  
    INT Carry, Places, bits, Guard, Guard2, dummy :
    SEQ
      Places := (BitsPerWord * 4) - (Xexp + 1)
      IF
        --{{{  prepare for shift into Xint
        Places >= (BitsPerWord * 4)          --Xexp <= -1
          SEQ
            --{{{  
            Xint[3] := 0
            Xint[2] := 0
            Xint[1] := 0
            Xint[0] := 0
            Guard := Xfrac[3]
            Guard2 := (Xfrac[2] \/ Xfrac[1]) \/ Xfrac[0]
            bits := Places - (BitsPerWord * 4)
            --}}}
        Places >= (BitsPerWord * 3)
          SEQ
            --{{{  
            Xint[3] := 0
            Xint[2] := 0
            Xint[1] := 0
            Xint[0] := Xfrac[3]
            Guard := Xfrac[2]
            Guard2 := Xfrac[1] \/ Xfrac[0]
            bits := Places - (BitsPerWord * 3)
            --}}}
        Places >= (BitsPerWord * 2)
          SEQ
            --{{{  
            Xint[3] := 0
            Xint[2] := 0
            Xint[1] := Xfrac[3]
            Xint[0] := Xfrac[2]
            Guard := Xfrac[1]
            Guard2 := Xfrac[0]
            bits := Places - (BitsPerWord * 2)
            --}}}
        Places >= BitsPerWord                --in word shift
          SEQ
            --{{{  
            Xint[3] := 0
            Xint[2] := Xfrac[3]
            Xint[1] := Xfrac[2]
            Xint[0] := Xfrac[1]
            Guard := Xfrac[0]
            Guard2 := 0
            bits := Places - BitsPerWord
            --}}}
        TRUE
          SEQ
            --{{{  
            Xint[3] := Xfrac[3]
            Xint[2] := Xfrac[2]
            Xint[1] := Xfrac[1]
            Xint[0] := Xfrac[0]
            Guard := 0
            Guard2 := 0
            bits := Places
            --}}}
        --}}}
      Guard2 := Guard2 \/ (Guard /\ (~SignBit))
      --{{{  set Xint before rounding
      dummy, Guard     := SHIFTRIGHT (Xint[0], Guard, bits)
      dummy, Xint[0]   := SHIFTRIGHT (Xint[1], Xint[0], bits)
      dummy, Xint[1]   := SHIFTRIGHT (Xint[2], Xint[1], bits)
      Xint[3], Xint[2] := SHIFTRIGHT (Xint[3], Xint[2], bits)
      --}}}
      IF
        --{{{  round
        ( Guard = 0 ) AND ( Guard2 = 0 )--no rounding to do
          SKIP                          --leave direction as is
        (Guard /\ SignBit) = 0          --do not round
          direction := rounded.down
        ((Guard /\ (~SignBit)) = 0 ) AND
        ( Guard2 = 0 )                  --exactly half
          IF
            direction = exact
              IF                        --make sure that the lsb of Xint is zero
                (Xint[0] /\ 1) = 0      --lsb of Xint is already zero
                  direction := rounded.down
                TRUE
                  SEQ
                    direction := rounded.up
                    --{{{  long arithmetic
                    Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
                    Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
                    Carry, Xint[2] := LONGSUM (Xint[2], 0, Carry)
                    Carry, Xint[3] := LONGSUM (Xint[3], 0, Carry)
                    --}}}
            direction = rounded.up
              direction := rounded.down
            TRUE                        --direction = rounded.down
              SEQ
                direction := rounded.up
                --{{{  long arithmetic
                Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
                Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
                Carry, Xint[2] := LONGSUM (Xint[2], 0, Carry)
                Carry, Xint[3] := LONGSUM (Xint[3], 0, Carry)
                --}}}
        TRUE                            --all of the guard is > #80000000
          SEQ                           --round up integer
            direction := rounded.up
            --{{{  long arithmetic
            Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
            Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
            Carry, Xint[2] := LONGSUM (Xint[2], 0, Carry)
            Carry, Xint[3] := LONGSUM (Xint[3], 0, Carry)
            --}}}
        --}}}
      --{{{  regain Xexp and Xfrac
      -- Now obtain the Xexp and Xfrac appropriate to Xint: they are not
      -- necessarily as before because of the possible rounding that
      -- was performed on Xint
      QUADSHIFTLEFT (Xfrac, Carry, Xint, 0, Places)
      IF
        --{{{  see if carry to exp
        Places >= (BitsPerWord * 4)
          Carry := Xint[0]               --only chance if rounded up
        Places >= (BitsPerWord * 3)
          Carry, dummy := SHIFTLEFT (0, Xint[0], bits) --see if carry to exp
        Places >= (BitsPerWord * 2)
          Carry, dummy := SHIFTLEFT (0, Xint[1], bits) --see if carry to exp
        Places >= BitsPerWord
          Carry, dummy := SHIFTLEFT (0, Xint[2], bits) --see if carry to exp
        TRUE
          Carry, dummy := SHIFTLEFT (0, Xint[3], bits) --see if carry to exp
        --}}}
      IF
        Carry <> 0
          SEQ
            Xexp := Xexp + Carry
            Xfrac[3] := SignBit
        TRUE
          SKIP
      --}}}
  :
  --}}}
  --{{{  WriteDec
  PROC WriteDec ([]BYTE Buf, INT Length, VAL [4]INT Num)
  
    --{{{  specification
    -- Purpose: To take an unsigned integer and convert it to the
    --          corresponding ASCII string, with the caveat that
    --          trailing zeros are not written.
    -- Out:     Buf - contains the ASCII string representing the
    --          integer ( Num ) ( apart from trailing zeros ); the
    --          string is [ Buf FROM 0 FOR Length ]
    -- Out:     Length - the number of meaningful characters in Buf
    -- In:      Num - the integer to be converted, assumed unsigned:
    --          numbers from 0 to 4,294,967,295 inclusive, for 32-bit
    --          processors, or 0 to 65535 inclusive, for 16-bit
    --          processors
    -- Notes:   An example of what is meant by not writing trailing
    --          zeros to Buf: if Num = 30, Length will be 1 and
    --          Buf[ 0 ] = '3' will be the only defined character
    --          in Buf.
    --}}}
  
    [4]INT N :
    INT ix, iy, T :
    SEQ
      N := Num                          --Num is VAL, use N as variable
      ix := 0                           --build in reverse order
      WHILE (((N[3] \/ N[2]) \/ N[1]) \/ N[0]) <> 0
        SEQ
          --{{{  effect N := N / 10; T := N REM 10
          N[3], T := LONGDIV (0, N[3], 10)
          N[2], T := LONGDIV (T, N[2], 10)
          N[1], T := LONGDIV (T, N[1], 10)
          N[0], T := LONGDIV (T, N[0], 10)
          --}}}
          IF
            (ix \/ T) = 0               --dump trailing zeros
              SKIP
            TRUE
              SEQ
                Buf[ix] := (BYTE (T + (INT '0'))) --convert from integer to ASCII equivalent
                ix := ix + 1
      Length := ix
      --{{{  reverse the list of digits
      ix := ix - 1                      --index of last digit
      iy := 0                           --index of first digit
      WHILE iy < ix
        BYTE b :
        SEQ                             --swap two elements
          b := Buf[ix]
          Buf[ix] := Buf[iy]
          Buf[iy] := b
          iy := iy + 1
          ix := ix - 1
      --}}}
  :
  --}}}
  --{{{  restrict
  PROC restrict ([]BYTE Buf, INT Places, LogX, VAL INT digits, INT direction)
  
    --{{{  specification
    -- Purpose: To round a number that is given in the form of a character
    --          string.
    -- In/Out:  Buf - the character string holding the number, assumed not to
    --          have trailing zeroes
    -- In/Out:  Places - the actual number of characters in the string
    -- In/Out:  LogX - floor( log10( number in Buf ) )
    -- In:      digits - the number of digits wanted in the rounded number;
    --          assumed greater than or equal to zero
    -- In/Out:  direction - this parameter is applicable only for numbers
    --          in Buf ending in 5: equal to -1 if the exact value was
    --          rounded down; equal to 0 if the value in Buf is
    --          exact; equal to +1 if the exact value was rounded up
    -- Notes:   "... if the two nearest representable values are equally near,
    --          the one with its least significant bit zero shall be delivered."
    --          IEEE 754-1985, Sec 4.1.  LSB zero <=> last digit is even.
    --          Any resultant trailing zeroes in Buf are elided.
    --}}}
  
    SEQ
      IF
        digits >= Places
          SKIP                              --nothing to do
        TRUE
          INT pos, carry :
          BOOL exactly.half, round.up :
          --{{{  check for rounding, and do if necessary
          SEQ
            --{{{  set exactly.half
            IF
              Buf[digits] = '5'   --then we must check for 0.50000....
                SEQ
                  exactly.half := TRUE
                  SEQ i = 1 FOR ( ( Places - digits ) - 1 )  --Places - digits - 1 >= 0
                    IF
                      exactly.half
                        exactly.half := ( Buf[digits + i] = '0' )
                      TRUE
                        SKIP
              TRUE
                exactly.half := FALSE
            --}}}
            --{{{  set round.up
            IF
              exactly.half
                -- round up if direction = rounded.down; round up if direction = exact
                -- and digit before 5 is odd; else leave as is
                IF
                  digits = 0
                    round.up := FALSE
                  direction = rounded.down
                    round.up := TRUE
                  TRUE
                    round.up :=  ( direction = exact ) AND
                                 ( ( Buf[digits - 1] = '1' ) OR
                                   ( Buf[digits - 1] = '3' ) OR
                                   ( Buf[digits - 1] = '5' ) OR
                                   ( Buf[digits - 1] = '7' ) OR
                                   ( Buf[digits - 1] = '9' ) )
              TRUE
                round.up := Buf[digits] >= '5'
            --}}}
            IF
              round.up
                --{{{  round up
                SEQ
                  direction := rounded.up
                  pos := digits - 1         --index of first digit to increment
                  carry := 1
                  WHILE (pos >= 0) AND (carry = 1)
                    SEQ
                      carry := (INT Buf[pos]) + carry
                      IF
                        carry > (INT '9')
                          SEQ
                            Buf[pos] := (BYTE (carry - 10))
                            carry := 1
                        TRUE
                          SEQ
                            Buf[pos] := (BYTE carry)
                            carry := 0
                      pos := pos - 1
                  --{{{  check for overflow on increment
                  IF
                    carry = 1
                      SEQ
                        Buf[0] := '1'
                        Places := 1
                        LogX := LogX + 1    --overflowed into extra digit
                    TRUE
                      Places := digits
                  --}}}
                --}}}
              TRUE
                SEQ
                  direction := rounded.down --cannot be exact because no trailing zeroes in Buf
                  Places := digits          --no rounding up to do
          --}}}
      WHILE (Places > 1) AND (Buf [Places - 1] = '0')
        Places := Places - 1                --drop trailing zeroes
  :
  --}}}
  --{{{  put.byte
  PROC put.byte (VAL BYTE byte)
    SEQ
      string [len] := byte
      len := len + 1
  :
  --}}}

  --{{{  declarations
  [ QMaxDecN ]BYTE Buf, Buf.1 :
  INT Carry, LogX, Y, Z, N, Places, Scale, Places.1, LogX.1 :
  INT Xexp, Yexp :
  [ 4 ]INT Xfrac, Xint, Yfrac, temp :
  INT round.direction :
  VAL INT max.no.of.zeroes.before.first.significant.digit IS 3 :
  VAL BYTE decimal.point IS '.' :
  --}}}

  --{{{  main body
  IF
    ( Ip < 0 ) OR ( Dp < 0 ) OR ( ( Ip > 0 ) AND ( Dp = 0 ) ) --meaningless combinations
      STOP
    TRUE
      --{{{  working body
      SEQ
        len := 0
        Xexp, Xfrac[3] := SHIFTLEFT (0, X[3] /\ (~SignBit), QRealShift + 1)
        IF
          Xexp = QRealExp
            --{{{  Inf or NaN
            SEQ
              --{{{  output sign for Inf
              IF
                ((X[3] /\ SignBit) = 0) OR
                    ((((Xfrac[3] \/ X[2]) \/ X[1]) \/ X[0]) <> 0)
                  IF
                    Dp = 0                        --free format so no space on +ve X
                      SEQ
                    TRUE
                      put.byte (' ')
                TRUE
                  put.byte ('-')
              --}}}
              IF
                (((Xfrac[3] \/ X[2]) \/ X[1]) \/ X[0]) = 0
                  [string FROM len FOR 3] := "Inf"
                TRUE
                  [string FROM len FOR 3] := "NaN"
              len := len + 3
              --{{{  space fill
              IF
                Ip <> 0                     --pad with spaces
                  SEQ i = 0 FOR (Ip + Dp) - 2
                    put.byte (' ')
                Dp <> 0
                  SEQ i = 0 FOR Dp + 3      -- include e+nnn
                    put.byte (' ')
                TRUE
                  SEQ
              --}}}
            --}}}
          ((((Xexp \/ Xfrac[3]) \/ X[2]) \/ X[1]) \/ X[0]) = 0
            --{{{  zero
            SEQ
              IF
                Ip = 0
                  SKIP
                TRUE                              --fixed point
                  SEQ i = 0 FOR Ip - 1
                    put.byte (' ')
              --{{{  output sign for zero
              IF
                ((X[3] /\ SignBit) = 0)
                  IF
                    Dp = 0                        --free format so no space on +ve X
                      SKIP
                    TRUE
                      put.byte (' ')
                TRUE
                  put.byte ('-')
              --}}}
              IF
                Dp = 0
                  --{{{  free format
                  SEQ
                    put.byte('0')
                    put.byte(decimal.point)
                    put.byte('0')
                  --}}}
                Ip <> 0
                  --{{{  fixed point
                  SEQ
                    put.byte('0')
                    put.byte(decimal.point)
                    SEQ j = 1 FOR Dp
                      put.byte('0')
                  --}}}
                TRUE
                  --{{{  exponential format
                  SEQ
                    IF
                      Dp = 1
                        put.byte(' ')
                      TRUE
                        SKIP
                    put.byte('0')
                    IF
                      Dp = 1
                        SKIP
                      TRUE
                        SEQ
                          put.byte(decimal.point)
                          SEQ i = 1 FOR Dp - 1
                            put.byte('0')
                    put.byte('E')
                    put.byte('+')
                    put.byte('0')
                    put.byte('0')
                    put.byte('0')
                  --}}}
            --}}}
          TRUE
            --{{{  proper case
            SEQ
              --{{{  get mantissa and exponent
              IF
                Xexp = 0                    --ensure normal
                  SEQ
                    --{{{  long arithmetic
                    Xfrac[3], Carry    := SHIFTLEFT (X[3], X[2], QRealShift + 1)
                    Xfrac[2], Carry    := SHIFTLEFT (X[2], X[1], QRealShift + 1)
                    Xfrac[1], Xfrac[0] := SHIFTLEFT (X[1], X[0], QRealShift + 1)
                    --}}}
                    temp := Xfrac
                    QUADNORMALISE (Places, Xfrac, Carry, temp, 0)
                    Xexp := -(Places + QRealXcess)
                TRUE                        --get correct fraction
                  SEQ
                    --{{{  long arithmetic
                    Xfrac[3], Carry    := SHIFTLEFT (X[3], X[2], QRealShift)
                    Xfrac[2], Carry    := SHIFTLEFT (X[2], X[1], QRealShift)
                    Xfrac[1], Xfrac[0] := SHIFTLEFT (X[1], X[0], QRealShift)
                    --}}}
                    Xfrac[3] := Xfrac[3] \/ SignBit
                    Xexp := Xexp - QRealXcess
              --}}}
              --{{{  form string representation
              Yexp := Xexp                  --save extended X
              Yfrac[3] := Xfrac[3]
              Yfrac[2] := Xfrac[2]
              Yfrac[1] := Xfrac[1]
              Yfrac[0] := Xfrac[0]
              QuickLog (LogX, Xexp, Xfrac)  --get log
              --{{{  get field width
              IF
                Dp <> 0
                  SEQ
                    N := Ip + Dp            --significant digits
                    IF
                      N > QMaxDecN          --don't print too many
                        N := QMaxDecN
                      TRUE
                        SKIP
                TRUE
                  N := QMaxDecN             --default
              --}}}
              Scale := (N - 1) - LogX
              QScaleX (Xexp, Xfrac, Scale, round.direction) --get X in range
              Round (Xexp, Xfrac, Xint, round.direction)    --now as integer
              -- now check that the rounding or too small a value of LogX has not
              -- given us more digits than we originally asked for, and take
              -- appropriate action if it did
              Z := N << 2
              --{{{  
              Carry, Y := LONGDIFF (Xfrac[0], QPowerTenFrac[Z], 0)
              Carry, Y := LONGDIFF (Xfrac[1], QPowerTenFrac[Z + 1], Carry)
              Carry, Y := LONGDIFF (Xfrac[2], QPowerTenFrac[Z + 2], Carry)
              Carry, Y := LONGDIFF (Xfrac[3], QPowerTenFrac[Z + 3], Carry)
              --}}}
              --{{{  
              IF
                (Xexp > PowerTenExp[N]) OR ((Xexp = PowerTenExp[N]) AND (Carry = 0))
                  SEQ
                    LogX := LogX + 1        --new scale
                    Xexp := Yexp            --reset X
                    Xfrac[3] := Yfrac[3]
                    Xfrac[2] := Yfrac[2]
                    Xfrac[1] := Yfrac[1]
                    Xfrac[0] := Yfrac[0]
                    QScaleX (Xexp, Xfrac, Scale - 1, round.direction)
                    Round (Xexp, Xfrac, Xint, round.direction)
                TRUE
                  SKIP
              --}}}
              Z := (N - 1) << 2
              --{{{  
              Carry, Y := LONGDIFF (Xfrac[0], QPowerTenFrac[Z], 0)
              Carry, Y := LONGDIFF (Xfrac[1], QPowerTenFrac[Z + 1], Carry)
              Carry, Y := LONGDIFF (Xfrac[2], QPowerTenFrac[Z + 2], Carry)
              Carry, Y := LONGDIFF (Xfrac[3], QPowerTenFrac[Z + 3], Carry)
              --}}}
              --{{{  
              IF
                (Xexp < PowerTenExp[N - 1]) OR ((Xexp = PowerTenExp[N - 1]) AND
                 (Carry <> 0))
                  SEQ                       --underflow power ten
                    Xexp := PowerTenExp[N - 1]
                    Xfrac[3] := QPowerTenFrac[(N << 2) - 1]
                    Xfrac[2] := QPowerTenFrac[(N << 2) - 2]
                    Xfrac[1] := QPowerTenFrac[(N << 2) - 3]
                    Xfrac[0] := QPowerTenFrac[(N << 2) - 4]
                    Round (Xexp, Xfrac, Xint, round.direction)
                    LogX := LogX - 1
                TRUE
                  SKIP
              --}}}
              WriteDec (Buf, Places, Xint)  --get number string
              --}}}
              --{{{  output the string in the correct format
              --{{{  fractional mode
              IF
                ( (Ip <> 0) AND (LogX < Ip) ) OR
                  ( (Dp = 0) AND (LogX < N) AND
                    (((-max.no.of.zeroes.before.first.significant.digit) - 1) <= LogX) )
                  --{{{  try to output in mmm.nnnn form
                  SEQ
                    Y := (Dp + LogX) + 1             --current estimate at actual field width
                    IF                               --must ensure that Y >= 0
                      Y < 0
                        Y := 0
                      TRUE
                        SKIP
                    SEQ i = 0 FOR Places
                      Buf.1[i] := Buf[i]
                    Places.1 := Places
                    LogX.1 := LogX
                    IF
                      Dp <> 0
                        restrict (Buf.1, Places.1, LogX.1, Y, round.direction)
                      TRUE
                        SKIP
                    IF
                      ( (Ip <> 0) AND (LogX.1 < Ip) ) OR
                        ( (Dp = 0) AND (LogX.1 < N) AND
                          (((-max.no.of.zeroes.before.first.significant.digit) - 1) <= LogX.1) )
                        --{{{  output in mmm.nnn form
                        SEQ
                          --{{{  set Scale
                          IF
                            LogX.1 < 0                   --always 0decimal.point
                              Scale := 1
                            TRUE
                              Scale := LogX.1 + 1
                          --}}}
                          --the value of Scale is the number of digits that there will be before the decimal.point
                          --{{{  pad with leading spaces to make up desired Ip
                          IF
                            Ip < Scale
                              SKIP
                            TRUE
                              SEQ i = 0 FOR Ip - Scale
                                put.byte (' ')
                          --}}}
                          N := Scale + Dp                --reduce remaining field width
                          --{{{  deal with sign
                          IF
                            (X[3] /\ SignBit) = 0        --positive sign
                              IF
                                Dp = 0                   --free format
                                  SKIP
                                TRUE
                                  put.byte (' ')
                            TRUE
                              put.byte ('-')
                          --}}}
                          --{{{  output 0decimal.point if number < 1
                          IF
                            LogX.1 < 0                    --less than 1
                              SEQ
                                put.byte ('0')
                                put.byte (decimal.point)
                                N := N - 1
                            TRUE
                              SKIP
                          --}}}
                          Scale := LogX.1 + 1             --check if < 0
                          --{{{  insert zeroes after decimal.point but before first significant digit ( if there is one )
                          IF
                            Dp = 0                            --free format
                              WHILE Scale < 0
                                SEQ
                                  put.byte ('0')
                                  Scale := Scale + 1
                            TRUE
                              WHILE ( Scale < 0 ) AND ( N > 0 )
                                SEQ
                                  put.byte ('0')
                                  Scale := Scale + 1
                                  N := N - 1                  --a digit has been output
                          --}}}
                          Scale := 0                      --places after point
                          IF
                            Dp <> 0
                              SKIP
                            TRUE
                              N := QMaxDecN               --free format: use as many digits as possible
                          restrict (Buf.1, Places.1, LogX.1, N, round.direction)
                          --{{{  output significant digits and trailing zeroes
                          SEQ i = 0 FOR N                 --number of valid digits
                            SEQ
                              IF
                                i < Places.1              --in buffer
                                  put.byte (Buf.1[i])
                                i <= (LogX.1 + 1)         --integer part (or 0 after point)
                                  put.byte ('0')
                                Dp > 0                    --use trailing zeroes; IEEE 5.6 says we can
                                  put.byte ('0')
                                TRUE
                                  SKIP
                              IF
                                i = LogX.1                --decimal point
                                  put.byte (decimal.point)
                                TRUE
                                  SKIP
                          --}}}
                          --{{{  deal with situation if ended with decimal.point
                          IF
                            (LogX.1 + 1) = N              --ended with decimal.point
                              SEQ
                                put.byte ('0')
                                Scale := Scale + 1
                            TRUE
                              SKIP
                          --}}}
                          Places := 0                     --set output already flag
                        --}}}
                      TRUE
                        SKIP                         --has overflowed into exponential form
                  --}}}
                TRUE
                  SKIP
              --}}}
              --{{{  exponential - output sign and check forced exponential field width
              IF
                Places = 0                  --number already output
                  SKIP
                TRUE
                  --{{{  show sign and adjust field width for forced exponent
                  SEQ
                    --{{{  output sign
                    IF
                      (X[3] /\ SignBit) <> 0
                        put.byte ('-')
                      Dp <> 0
                        put.byte (' ')
                      TRUE                         --free format
                        SKIP
                    --}}}
                    IF
                      Ip <> 0                       --exp form forced so make new mantissa width
                        --{{{  
                        SEQ
                          N := (Ip + Dp) - 5 --N is here the number of digits in exponential format;
                                             --total field width is number of digits(N) + 7, but this
                                             --must also equal Ip+Dp+2. Hence N must be Ip+Dp+2-7.
                          IF
                            N < 0
                              --{{{  display overflow
                              SEQ
                                put.byte ('O')
                                put.byte ('v')
                                SEQ i = 0 FOR (Ip + Dp) - 1      -- 3 chars of field already output
                                  put.byte (' ')
                                Places := 0                      --set finished flag
                              --}}}
                            TRUE
                              SEQ
                                IF
                                  N = 1
                                    put.byte (' ')  --fix when not enough space for any decimals
                                  N = 0
                                    N := 1          --ditto
                                  TRUE
                                    SKIP
                                restrict (Buf, Places, LogX, N, round.direction)
                        --}}}
                      TRUE
                        --{{{  set N
                        SEQ
                          N := Dp                   --free or fixed mantissa size exponent form
                          IF
                            N = 1
                              put.byte (' ')        --extra space to replace missing decimal.point
                            TRUE
                              SKIP
                        --}}}
                  --}}}
              --}}}
              --{{{  exponential form of output
              IF
                Places = 0                  --number already output
                  SKIP
                TRUE
                  --{{{  output in exponential form
                  SEQ
                    put.byte (Buf[0])
                    IF
                      N <> 1
                        put.byte (decimal.point)     --more digits to come so output the decimal.point
                      TRUE
                        SKIP
                    IF
                      N <> 0                         --exp form requested
                        SEQ
                          SEQ i = 1 FOR N - 1
                            IF
                              i < Places
                                put.byte (Buf[i])
                              i = 1                  --only one digit
                                put.byte ('0')
                              TRUE                   --zero fill field
                                put.byte ('0')
                      Places <= 1                    --only one digit
                        put.byte ('0')
                      TRUE                           --output all digits
                        SEQ i = 1 FOR Places - 1
                          put.byte (Buf[i])
                    --{{{  E+/-eee
                    put.byte ('E')
                    IF
                      LogX < 0
                        SEQ
                          put.byte ('-')
                          LogX := -LogX
                      TRUE
                        put.byte ('+')
                    --now for the three digit exponent
                    put.byte (BYTE (((LogX / 100) \ 10) + (INT '0')))
                    put.byte (BYTE (((LogX / 10) \ 10) + (INT '0')))
                    put.byte (BYTE ((LogX \ 10) + (INT '0')))
                    --}}}
                  --}}}
              --}}}
              --}}}
            --}}}
      --}}}
  --}}}
:
