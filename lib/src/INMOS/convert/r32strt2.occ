--{{{  all sorts of #'s
#OPTION "E V" -- no compiler libraries, no vector space
#COMMENT "Type conversion library V1.7 4/12/90"
#COMMENT "(c) Copyright INMOS Limited 1988, 1990"
#PRAGMA TRANSLATE RealIDiv "RealIDiv%CHK"
#PRAGMA TRANSLATE RealIMul "RealIMul%CHK"
#USE "occamutl.lib"
--}}}
PROC REAL32TOSTRING (INT len, []BYTE string, VAL REAL32 X, VAL INT Ip, Dp)

  --{{{  specification
  -- Purpose:  To take a binary representation of a real number and convert
  --           it into a string of characters that is the decimal
  --           representation of that number, formatted according to given
  --           rules ( see Notes below ).
  -- Out:      len - the number of characters ( BYTEs ) of string occupied
  --           by the formatted decimal representation of the real number
  -- Out:      string - an array containing the formatted decimal
  --           representation of the real number in the first len bytes,
  --           the remaining bytes being undefined
  -- In:       X - the real number, in IEEE format, to be converted
  -- In:       Ip - the first of two formatting values
  -- In:       Dp - the second of two formatting values
  --{{{  Notes
  -- Notes:    Rounding mode is round to nearest.
  --           Which format is used depends on the combination of values
  --           of Ip, Dp and X.  In all cases, any digits beyond the 9th
  --           significant digit for single precision or 17th significant
  --           digit for double precision will be given as 0 and cannot
  --           be considered accurate.
  --           If string overflows this routine acts as an invalid process.
  --{{{  Case i
  -- Case (i):    Ip = 0, Dp = 0  => free format
  --           Where possible a fixed point representation is used.  If
  --           it is not used then exponential form is used.  It is not
  --           used if more than 9 | 17 significant digits of accuracy
  --           ( single | double ) would be required before the decimal
  --           point, or if there are more than 3 zeroes after the decimal
  --           point before the first significant digit.  In any case, the
  --           maximum number of characters returned in string is 15 for a
  --           single precision X, and 24 for a double precision X.
  --           string is left justified.
  --           If X is infinity or a NaN, then the string will contain one
  --           of "Inf", "-Inf" or "NaN", but not the quotes.
  --}}}
  --{{{  Case ii
  -- Case (ii):   Ip = 0, Dp > 0  => exponential format
  --           The form of exponential format is, firstly either a minus
  --           sign or a space ( this latter instead of an explicit plus
  --           sign ), a fraction in the form <digit>.<digits>, the
  --           exponential symbol ( E ), the sign of the exponent ( + or
  --           - ), then the exponent, which is two digits for a single
  --           precision X, three digits for a double precision X.  Dp
  --           gives the number of digits in the fraction ( 1 before the
  --           point, and the others after, but not counting the point ).
  --           The total number of characters in string is ( Dp + 6 )
  --           for a single precision X, and ( Dp + 7 ) for a double
  --           precision X.
  --           If Dp = 1 then the fraction is of the form <space>digit
  --           ( which, note, will not result in occam syntax for the
  --           real ).
  --           If X is infinity or a NaN, then the string will contain one
  --           of " Inf", "-Inf" or " NaN", but not the quotes, padded on
  --           the right to fill the field width.
  --}}}
  --{{{  Case iii
  -- Case (iii):  Ip > 0, Dp > 0  => fixed point if possible
  --           Ip gives the number of places before the point, not
  --           counting the sign place; Dp the number of places after
  --           the point.  Padding spaces are added on the left as
  --           necessary.  If the number will not fit the format,
  --           then an exponential format is used with the same field
  --           width as the fixed point representation would have had.
  --           If Ip and Dp are very small then an exponential
  --           representation may not fit in the field width so the
  --           special value "Ov" with a sign is returned.
  --           There are always ( Ip + Dp + 2 ) characters in string,
  --           the 2 being the decimal point and the sign ( - or space ).
  --           If X is infinity or a NaN, then the string will contain one
  --           of " Inf", "-Inf" or " NaN", but not the quotes, padded on
  --           the right to fill the field width.
  --}}}
  -- All other combinations of Ip and Dp are meaningless and will cause
  --           an error.
  --}}}
  --}}}
  --{{{  history
  -- V1.0, 1-Jul-88
  -- Added V to the OPTIONs; V1.1, 22-Mar-90 SRH
  -- Formatting completely revamped; bug report number TS/37; V1.2,
  -- 26-Apr-90 SRH
  -- Added more comments; 5-Oct-90 SRH
  -- Removed the test ( Xexp >= ( BitsPerWord * 2 ) ) from Round because
  -- redundant; V1.3, 11-Oct-90 SRH
  -- Altered to take account of rounding done to numbers almost half
  -- way between two other numbers - round.direction introduced;  bug
  -- report number TS/789; V1.4, 6-Nov-90 SRH
  -- Removed a bit of redundant code ( that which used to display Un );
  -- V1.5, 15-Nov-90 SRH
  -- Replaced the internal routine DIMul by a reference to RealIMul
  -- because they did the same thing even though they had different
  -- interfaces and DIMul was a PROC - code size is subsequently
  -- reduced; also added in AND ( Carry = 0 ) to an IF in DScaleX
  -- for the divided exactly case - should have gone in with version
  -- 1.4; also corrected the TRUE branch of the IF in QuickLog by having
  -- Carry carried over into the second LONGPROD; V1.6, 28-Nov-90 SRH
  -- Added assignment to zero of Guard in DScaleX when overflow to
  -- infinity; this prevents possible addition of 1 to infinity to
  -- make a NaN; V1.7, 4-Dec-90 SRH
  --}}}
  --{{{  more information
  -- To help understand the binary to character conversion see "Contributions
  -- to a Proposed Standard for Binary Floating-Point Arithmetic" by J T Coonen,
  -- PhD thesis, 1984, University of California, Berkeley.
  --}}}

  VAL []INT X RETYPES X:

  --{{{  Definitions
  --{{{  Word length specific values for 16 bit machine
  VAL SignBit        IS #8000 :
  VAL BitsPerWord    IS    16 :
  VAL MaxUnsignedInt IS #FFFF :
  VAL BytesPerWord   IS     2 :
  --}}}
  --{{{  IEEE Single length constants for 16 bit implementation
  VAL DRealShift  IS     8 :
  VAL DBitsInFrac IS    24 :
  VAL DRealExpSh  IS     7 :
  VAL DRealExp    IS   255 :
  VAL DRealXcess  IS   127 :
  VAL DRealRBit   IS   128 :
  VAL DRealInf    IS #7F80 :
  --}}}
  --{{{  read/write constants
  -- write number constants
  VAL Table10 IS    13 : --exact power of ten in word
  VAL Bias10  IS     3 : --extras for full power ten range
  VAL MaxDecN IS     9 : --maximum dec digits; IEEE Sec 5.6
  VAL R2L     IS #4D10 : --Log10(2) = 0.3010299956639811952 for extended QuickLog
  
  -- The table PowerTenFrac contains the fraction with implicit bit
  -- explicit and then normalized so that there is a one bit in bit 31
  -- of powers of 10 from 10^0 to 10^13.  For example,
  -- 10^3 = 1111101000 in binary, which is 1.111101 * 2^9; so the fraction
  -- bits, with implicit bit explicit ( ie the 1 before the point kept ) is
  -- 1111101, and the actual exponent is 9.  This latter ( the actual
  -- exponent ) is what is in the corresponding table PowerTenExp.
  -- The index of an entry is the same as the power of 10 in
  -- PowerTenExp; hence PowerTenExp[ 3 ] = 9.  For PowerTenFrac twice
  -- the power of 10 gives the index of the lower word of the fraction,
  -- the upper word being in the next element; hence
  -- PowerTenFrac[ 2 * 3 ] = #0000 and PowerTenFrac[ 2 * 3 + 1 ] = #FA00.
  -- No bits are lost in the PowerTenFrac table; even the largest value,
  -- 10^13, is exact.
  -- These two tables of constants are simply set up in advance for
  -- efficiency.
  VAL PowerTenFrac IS [#0000, #8000, #0000, #A000, #0000, #C800,
   #0000, #FA00, #0000, #9C40, #0000, #C350, #0000, #F424, #8000,
   #9896, #2000, #BEBC, #2800, #EE6B, #F900, #9502, #B740, #BA43,
   #A510, #E8D4, #E72A, #9184] :
  
  VAL PowerTenExp IS [0, 3, 6, 9, 13, 16, 19, 23, 26, 29, 33, 36,
   39, 43] :
  
  VAL BiasTenFrac IS [#E72A, #9184, #8F28, #CECB, #4F8E, #EB19] : --P13, P27, P40
  
  VAL BiasTenExp IS [43, 89, 132] :
  
  VAL BiasTen IS [14, 28, 41, 54] :      --bias changeover points
  --}}}
  --{{{  rounding constants
  VAL INT rounded.down IS -1 :
  VAL INT exact        IS  0 :
  VAL INT rounded.up   IS  1 :
  --}}}
  --}}}
  --{{{  DScaleX
  PROC DScaleX (INT Xexp, [2]INT Xfrac, VAL INT Scale, INT direction)
  
    -- Scale X by value of 10^Scale
  
    INT Carry, Guard, Places, Sb, St, Zexp, dummy :
    [2]INT Zfrac :
    SEQ
      --{{{  get abs value of Scale
      IF
        Scale < 0
          St := -Scale
        TRUE
          St := Scale
      --}}}
      --{{{  set Zexp and Zfrac
      IF
        St <= Table10
          --{{{  easy case, 10 in table
          SEQ
            Zexp := PowerTenExp[St]
            Zfrac[0] := PowerTenFrac[St + St]
            Zfrac[1] := PowerTenFrac[(St + St) + 1]
          --}}}
        St = (BiasTen[1] - 1)
          --{{{  special case
          SEQ
            Zexp := BiasTenExp[1]
            Zfrac[0] := BiasTenFrac[2]
            Zfrac[1] := BiasTenFrac[3]
          --}}}
        TRUE
          --{{{  apply bias
          SEQ
            IF                              --get power ten bias
              IF i = 0 FOR Bias10
                St < BiasTen[i + 1]
                  Sb := i
              TRUE                          --too big
                Sb := -1
            IF
              Sb < 0                        --too large
                Zexp := -1
              TRUE
                --{{{  valid power
                SEQ
                  St := (St - BiasTen[Sb]) + 1
                  Zexp := (PowerTenExp[St] + BiasTenExp[Sb]) + 1
                  Zfrac[0] := PowerTenFrac[St + St]
                  Zfrac[1] := PowerTenFrac[(St + St) + 1]
                  Zfrac[1], Zfrac[0], Guard := RealIMul( Zfrac,
                    [ BiasTenFrac FROM ( Sb + Sb ) FOR 2 ] )
                  Places, Zfrac[1], dummy := NORMALISE (Zfrac[1], Zfrac[0])
                  Zfrac[0], Guard         := SHIFTLEFT (Zfrac[0], Guard, Places)
                  Zexp := Zexp - Places
                --}}}
          --}}}
      --}}}
      --{{{  set Xexp, Xfrac and Guard
      IF
        Zexp < 0
          --{{{  out of range
          SEQ
            IF
              Scale < 0                     --set to big number
                Xexp := -DRealExp
              TRUE
                Xexp := DRealExp
            Xfrac[1] := SignBit             --prevent normalisation
            Xfrac[0] := 0
            Guard := 0
          --}}}
        Scale < 0
          --{{{  scale down
          SEQ
            Xexp := Xexp - Zexp
            Xfrac[1], Xfrac[0] := SHIFTRIGHT (Xfrac[1], Xfrac[0], 1)
            Xfrac[1], Xfrac[0], Guard :=
              RealIDiv (Xfrac[1], Xfrac[0], 0, Zfrac)
            Xfrac[0], Guard, Carry :=
              RealIDiv (Xfrac[0], Guard, 0, Zfrac)
          
            -- original code to assign Guard:
            --INT Borrow :
            --SEQ                             --see if over half left
            --  Zfrac[1], Zfrac[0] := SHIFTRIGHT (Zfrac[1], Zfrac[0], 1)
            --  Borrow, dummy := LONGDIFF (Carry, Zfrac[0], 0)
            --  Borrow, dummy := LONGDIFF (Guard, Zfrac[1], Borrow)
            --  IF
            --    Borrow <> 0                 --less than half
            --      Guard := 0
            --    TRUE                        --note sticky bit
            --      Guard := SignBit
          
            --{{{  obtain more accurate Guard - matters in assignment of direction later
            IF
              ( Guard = 0 ) AND ( Carry = 0 )
                SKIP                          --divided exactly
              TRUE
                INT remainder.hi, remainder.low :
                Guard, remainder.hi, remainder.low := RealIDiv( Guard, Carry, 0, Zfrac )
            --}}}
          --}}}
        TRUE
          --{{{  scale up
          SEQ
            Xexp := (Xexp + Zexp) + 1
            Xfrac[1], Xfrac[0], Guard := RealIMul( Xfrac, Zfrac )
          --}}}
      --}}}
      --{{{  normalise
      Places, Xfrac[1], dummy := NORMALISE (Xfrac[1], Xfrac[0])
      Xfrac[0], Guard         := SHIFTLEFT (Xfrac[0], Guard, Places)
      Xexp := Xexp - Places
      --}}}
      --{{{  round and set direction
      IF
        Guard = 0
          direction := exact
        (Guard /\ SignBit) = 0
          direction := rounded.down
        TRUE
          SEQ
            direction := rounded.up
            Carry, Xfrac[0] := LONGSUM (Xfrac[0], 1, 0)
            Carry, Xfrac[1] := LONGSUM (Xfrac[1], 0, Carry)
            IF
              Carry <> 0
                SEQ
                  Xexp := Xexp + 1
                  Xfrac[1] := SignBit
              TRUE
                SKIP
      --}}}
  :
  --}}}
  --{{{  QuickLog
  PROC QuickLog (INT LogX, VAL INT Xexp, VAL [2]INT Xfrac)
  
    -- Purpose: To be a cheap approximation of floor( Log10( X ) ), so
    --          cheap that it may be 1 too small.
    -- Out:     LogX - either floor( log10( X ) ) or floor( log10( X ) ) - 1
    -- In:      Xexp - actual exponent, i.e. biased exponent - RealXcess
    -- In:      Xfrac - fractional part with the implicit bit explicit
    --          ( and normalised if from a denormal ) so that bit 31
    --          is 1
    -- Notes:   If Xexp = 0 = Xfrac, then LogX is returned as 0.
  
    INT X, Y :
    SEQ
      -- Use approximation of Log2( 1.f * 2^e ) as e.f, due to
      -- 0.f <= log2( 1.f ), with a maximum deviation of about 0.086
      X := Xexp
      Y := Xfrac[1] << 1
      IF
        X < 0                                     --log2 may be small
          INT Borrow, Carry :
          SEQ
            --{{{  long arithmetic
            Borrow, Y    := LONGDIFF (0, Y, 0)
            Borrow, X    := LONGDIFF (0, X, Borrow)
            Carry, Y     := LONGPROD (Y, R2L + 1, 0)
            Carry, X     := LONGPROD (X, R2L + 1, Carry)
            Borrow, Y    := LONGDIFF (0, Y, 0)
            Borrow, X    := LONGDIFF (0, X, Borrow)
            Borrow, LogX := LONGDIFF (0, Carry, Borrow)
            --}}}
        TRUE                                      --log2 about right
          INT Carry, dummy :
          SEQ                                     --mul by Log10(2)
            Carry, dummy := LONGPROD (Y, R2L, 0)
            LogX,  dummy := LONGPROD (X, R2L, Carry)
  :
  --}}}
  --{{{  Round
  PROC Round (INT Xexp, [2]INT Xfrac, Xint, INT direction)
  
    --{{{  specification
    -- Purpose: To round a real number to the nearest integer.
    -- In/Out:  Xexp - actual exponent, not biased one: on entry, of the
    --          number to round; on exit, of the rounded number
    -- In/Out:  Xfrac - the fractional part of the real with implicit bit
    --          explicit: on entry, of the number to round; on exit, of the
    --          rounded number
    -- Out:     Xint - the nearest integer that the combination of Xexp
    --          and Xfrac on entry give
    -- In/Out:  direction - this parameter is applicable only for numbers
    --          ending in 5: equal to rounded.down if the exact value was
    --          rounded down; equal to exact if the value on entry is
    --          exact; equal to rounded.up if the exact value was rounded up
    -- Notes:   ( Xexp on entry ) < ( 2 * the number of bits per word ) is
    --          assumed.
    --          This procedure only caters for non-negative numbers.
    --}}}
  
    INT Carry, Places, Guard, dummy :
    IF
      Xexp >= BitsPerWord
        SEQ
          --{{{  in word shift
          Places := (BitsPerWord * 2) - (Xexp + 1)
          Xint[1], Xint[0] := SHIFTRIGHT (Xfrac[1], Xfrac[0], Places)
          dummy, Guard     := SHIFTRIGHT (Xfrac[0], 0, Places)
          IF
            Guard = 0                    --no rounding to do
              SKIP                       --leave direction as is
            (Guard /\ SignBit) = 0       --do not round
              direction := rounded.down
            (Guard /\ (~SignBit)) = 0    --exactly half
              IF
                direction = exact
                  IF                     --make sure that the lsb of Xint is zero
                    (Xint[0] /\ 1) = 0   --lsb of Xint is already zero
                      direction :=rounded.down
                    TRUE
                      SEQ
                        direction := rounded.up
                        Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
                        Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
                direction = rounded.up
                  direction := rounded.down
                TRUE                     --direction = rounded.down
                  SEQ
                    direction := rounded.up
                    Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
                    Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
            TRUE                         --Guard > #8000
              SEQ                        --round integer up
                direction := rounded.up
                Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
                Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
          -- Now obtain the Xexp and Xfrac appropriate to Xint: they are not
          -- necessarily as on entry because of the possible rounding up that
          -- was performed on Xint.
          Xfrac[1], Xfrac[0] := SHIFTLEFT (Xint[1], Xint[0], Places)
          Carry, dummy := SHIFTLEFT (0, Xint[1], Places) --see if carry to exp
          Xexp := Xexp + Carry
          --}}}
      TRUE
        SEQ
          --{{{  past word shift
          Places := BitsPerWord - (Xexp + 1)
          Xint[1] := 0
          Xint[0], Guard := SHIFTRIGHT (Xfrac[1], Xfrac[0], Places)
          -- make sure that Guard reflects the situation; the SHIFTRIGHT may
          -- have lost bits of Xfrac[ 0 ]
          IF
            ( Xfrac[0] = 0 ) OR          --no sticky bits
            ( Places = 0 )               --Guard = Xfrac[0]
              SKIP
            TRUE
              Guard := Guard \/ 1
          IF
            Guard = 0                    --no rounding to do
              SKIP                       --leave direction as is
            (Guard /\ SignBit) = 0       --do not round
              direction := rounded.down
            (Guard /\ (~SignBit)) = 0    --exactly half
              IF
                direction = exact
                  IF                     --make sure that the lsb of Xint is zero
                    ( Xint[0] /\ 1 ) = 0 --lsb of Xint is already zero
                      direction := rounded.down
                    TRUE
                      SEQ
                        direction := rounded.up
                        Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
                        Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
                direction = rounded.up
                  direction := rounded.down
                TRUE                     --direction = rounded.down
                  SEQ
                    direction := rounded.up
                    Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
                    Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
            TRUE                         --Guard bits > #80000000
              SEQ                        --round integer up
                direction := rounded.up
                Carry, Xint[0] := LONGSUM (Xint[0], 1, 0)
                Carry, Xint[1] := LONGSUM (Xint[1], 0, Carry)
          Carry, Xfrac[1] := SHIFTLEFT (Xint[1], Xint[0], Places)
          Xfrac[0] := 0
          IF
            Carry <> 0
              SEQ
                Xexp := Xexp + Carry
                Xfrac[1] := SignBit
            TRUE
              SKIP
          --}}}
  :
  --}}}
  --{{{  WriteDec
  PROC WriteDec ([]BYTE Buf, INT Length, VAL [2]INT Num)
  
    --{{{  specification
    -- Purpose: To take an unsigned integer and convert it to the
    --          corresponding ASCII string, with the caveat that
    --          trailing zeros are not written.
    -- Out:     Buf - contains the ASCII string representing the
    --          integer ( Num ) ( apart from trailing zeros ); the
    --          string is [ Buf FROM 0 FOR Length ]
    -- Out:     Length - the number of meaningful characters in Buf
    -- In:      Num - the integer to be converted, assumed unsigned:
    --          numbers from 0 to 4,294,967,295 inclusive, for 32-bit
    --          processors, or 0 to 65535 inclusive, for 16-bit
    --          processors
    -- Notes:   An example of what is meant by not writing trailing
    --          zeros to Buf: if Num = 30, Length will be 1 and
    --          Buf[ 0 ] = '3' will be the only defined character
    --          in Buf.
    --}}}
  
    [2]INT N :
    INT ix, iy, T :
    SEQ
      N[0] := Num[0]
      N[1] := Num[1]
      ix := 0                           --build in reverse order
      WHILE (N[1] \/ N[0]) <> 0
        SEQ
          --{{{  effect N := N / 10; T := N REM 10
          N[1], T := LONGDIV (0, N[1], 10)
          N[0], T := LONGDIV (T, N[0], 10)
          --}}}
          IF
            (ix \/ T) = 0               --dump trailing zeros
              SKIP
            TRUE
              SEQ
                Buf[ix] := (BYTE (T + (INT '0'))) --convert from integer to ASCII equivalent
                ix := ix + 1
      Length := ix
      --{{{  reverse the list of digits
      ix := ix - 1                      --index of last digit
      iy := 0                           --index of first digit
      WHILE iy < ix
        BYTE b :
        SEQ                             --swap two elements
          b := Buf[ix]
          Buf[ix] := Buf[iy]
          Buf[iy] := b
          iy := iy + 1
          ix := ix - 1
      --}}}
  :
  --}}}
  --{{{  restrict
  PROC restrict ([]BYTE Buf, INT Places, LogX, VAL INT digits, INT direction)
  
    --{{{  specification
    -- Purpose: To round a number that is given in the form of a character
    --          string.
    -- In/Out:  Buf - the character string holding the number, assumed not to
    --          have trailing zeroes
    -- In/Out:  Places - the actual number of characters in the string
    -- In/Out:  LogX - floor( log10( number in Buf ) )
    -- In:      digits - the number of digits wanted in the rounded number;
    --          assumed greater than or equal to zero
    -- In/Out:  direction - this parameter is applicable only for numbers
    --          in Buf ending in 5: equal to -1 if the exact value was
    --          rounded down; equal to 0 if the value in Buf is
    --          exact; equal to +1 if the exact value was rounded up
    -- Notes:   "... if the two nearest representable values are equally near,
    --          the one with its least significant bit zero shall be delivered."
    --          IEEE 754-1985, Sec 4.1.  LSB zero <=> last digit is even.
    --          Any resultant trailing zeroes in Buf are elided.
    --}}}
  
    SEQ
      IF
        digits >= Places
          SKIP                              --nothing to do
        TRUE
          INT pos, carry :
          BOOL exactly.half, round.up :
          --{{{  check for rounding, and do if necessary
          SEQ
            --{{{  set exactly.half
            IF
              Buf[digits] = '5'   --then we must check for 0.50000....
                SEQ
                  exactly.half := TRUE
                  SEQ i = 1 FOR ( ( Places - digits ) - 1 )  --Places - digits - 1 >= 0
                    IF
                      exactly.half
                        exactly.half := ( Buf[digits + i] = '0' )
                      TRUE
                        SKIP
              TRUE
                exactly.half := FALSE
            --}}}
            --{{{  set round.up
            IF
              exactly.half
                -- round up if direction = rounded.down; round up if direction = exact
                -- and digit before 5 is odd; else leave as is
                IF
                  digits = 0
                    round.up := FALSE
                  direction = rounded.down
                    round.up := TRUE
                  TRUE
                    round.up :=  ( direction = exact ) AND
                                 ( ( Buf[digits - 1] = '1' ) OR
                                   ( Buf[digits - 1] = '3' ) OR
                                   ( Buf[digits - 1] = '5' ) OR
                                   ( Buf[digits - 1] = '7' ) OR
                                   ( Buf[digits - 1] = '9' ) )
              TRUE
                round.up := Buf[digits] >= '5'
            --}}}
            IF
              round.up
                --{{{  round up
                SEQ
                  direction := rounded.up
                  pos := digits - 1         --index of first digit to increment
                  carry := 1
                  WHILE (pos >= 0) AND (carry = 1)
                    SEQ
                      carry := (INT Buf[pos]) + carry
                      IF
                        carry > (INT '9')
                          SEQ
                            Buf[pos] := (BYTE (carry - 10))
                            carry := 1
                        TRUE
                          SEQ
                            Buf[pos] := (BYTE carry)
                            carry := 0
                      pos := pos - 1
                  --{{{  check for overflow on increment
                  IF
                    carry = 1
                      SEQ
                        Buf[0] := '1'
                        Places := 1
                        LogX := LogX + 1    --overflowed into extra digit
                    TRUE
                      Places := digits
                  --}}}
                --}}}
              TRUE
                SEQ
                  direction := rounded.down --cannot be exact because no trailing zeroes in Buf
                  Places := digits          --no rounding up to do
          --}}}
      WHILE (Places > 1) AND (Buf [Places - 1] = '0')
        Places := Places - 1                --drop trailing zeroes
  :
  --}}}
  --{{{  put.byte
  PROC put.byte (VAL BYTE byte)
    SEQ
      string [len] := byte
      len := len + 1
  :
  --}}}

  --{{{  declarations
  [MaxDecN] BYTE Buf, Buf.1 :
  INT Carry, LogX, N, Y, Places, Scale, LogX.1, Places.1 :
  INT Xexp, Yexp :
  [2] INT Xfrac, Xint, Yfrac :
  INT round.direction :
  VAL INT max.no.of.zeroes.before.first.significant.digit IS 3 :
  VAL BYTE decimal.point IS '.' :
  --}}}

  --{{{  main body
  IF
    ( Ip < 0 ) OR ( Dp < 0 ) OR ( ( Ip > 0 ) AND ( Dp = 0 ) ) --meaningless combinations
      STOP
    TRUE
      SEQ
        --{{{  working body
        len := 0
        Xexp, Xfrac[1] := SHIFTLEFT (0, X[1] /\ (~SignBit), DRealShift + 1)
        IF
          Xexp = DRealExp
            --{{{  inf or NaN
            SEQ
              --{{{  Show Sign for Inf
              IF                                  --output sign
                ((X[1] /\ SignBit) = 0) OR ((Xfrac[1] \/ X[0]) <> 0)
                  IF
                    Dp = 0                        --free format
                      SKIP
                    TRUE
                      put.byte (' ')
                TRUE
                  put.byte ('-')
              --}}}
              IF
                (Xfrac[1] \/ X[0]) = 0      --N.b. Inf is the unique case (not NaN)
                  [string FROM len FOR 3] := "Inf"
                TRUE
                  [string FROM len FOR 3] := "NaN"
              len := len + 3
              --{{{  space fill
              IF
                Ip <> 0                        --pad with spaces
                  SEQ i = 0 FOR (Ip + Dp) - 2  --so that there is a total of Ip + Dp + 2
                    put.byte (' ')
                Dp <> 0
                  SEQ i = 0 FOR Dp + 2         --include E+nn; total of Dp + 6
                    put.byte (' ')
                TRUE
                  SKIP
              --}}}
            --}}}
          ((Xexp \/ Xfrac[1]) \/ X[0]) = 0
            --{{{  zero
            SEQ
              IF
                Ip = 0
                  SKIP
                TRUE                                --fixed point
                  SEQ i = 0 FOR Ip - 1
                    put.byte (' ')
              --{{{  output sign
              IF
                ((X[1] /\ SignBit) = 0)
                  IF
                    Dp = 0                        --free format
                      SKIP
                    TRUE
                      put.byte (' ')
                TRUE
                  put.byte ('-')
              --}}}
              IF
                Dp = 0
                  --{{{  free format
                  SEQ
                    put.byte('0')
                    put.byte(decimal.point)
                    put.byte('0')
                  --}}}
                Ip <> 0
                  --{{{  fixed point
                  SEQ
                    put.byte('0')
                    put.byte(decimal.point)
                    SEQ j = 1 FOR Dp
                      put.byte('0')
                  --}}}
                TRUE
                  --{{{  exponential format
                  SEQ
                    IF
                      Dp = 1
                        put.byte(' ')
                      TRUE
                        SKIP
                    put.byte('0')
                    IF
                      Dp = 1
                        SKIP
                      TRUE
                        SEQ
                          put.byte(decimal.point)
                          SEQ i = 1 FOR Dp - 1
                            put.byte('0')
                    put.byte('E')
                    put.byte('+')
                    put.byte('0')
                    put.byte('0')
                  --}}}
            --}}}
          TRUE
            --{{{  proper value
            SEQ
              --{{{  seperate mantissa and exponent
              IF
                Xexp = 0                    --ensure normal
                  SEQ
                    Xfrac[1], Xfrac[0]         := SHIFTLEFT (X[1], X[0], DRealShift + 1)
                    Places, Xfrac[1], Xfrac[0] := NORMALISE (Xfrac[1], Xfrac[0])
                    Xexp := -(Places + DRealXcess)
                TRUE                        --get correct fraction
                  SEQ
                    Xfrac[1], Xfrac[0] := SHIFTLEFT (X[1], X[0], DRealShift)
                    Xfrac[1] := Xfrac[1] \/ SignBit
                    Xexp := Xexp - DRealXcess
              --}}}
              --{{{  Scale number to field size
              Yexp := Xexp                  --save extended X
              Yfrac[1] := Xfrac[1]
              Yfrac[0] := Xfrac[0]
              QuickLog (LogX, Xexp, Xfrac)  --get log
              --{{{  obtain number of significant digits required
              IF
                Dp <> 0
                  SEQ
                    N := Ip + Dp            --significant digits
                    IF
                      N > MaxDecN           --don't print too many
                        N := MaxDecN
                      TRUE
                        SKIP
                TRUE
                  N := MaxDecN              --default
              --}}}
              Scale := (N - 1) - LogX
              DScaleX (Xexp, Xfrac, Scale, round.direction)  --get X in range
              Round (Xexp, Xfrac, Xint, round.direction)     --now as integer
              -- now check that the rounding or too small a value of LogX has not
              -- given us more digits than we originally asked for, and take
              -- appropriate action if it did
              Carry, Y := LONGDIFF (Xfrac[0], PowerTenFrac[N + N], 0)
              Carry, Y := LONGDIFF (Xfrac[1], PowerTenFrac[(N + N) + 1], Carry)
              --{{{  
              IF
                (Xexp > PowerTenExp[N]) OR ((Xexp = PowerTenExp[N]) AND (Carry = 0))
                  SEQ
                    LogX := LogX + 1        --new scale
                    Xexp := Yexp            --reset X
                    Xfrac[1] := Yfrac[1]
                    Xfrac[0] := Yfrac[0]
                    DScaleX (Xexp, Xfrac, Scale - 1, round.direction)
                    Round (Xexp, Xfrac, Xint, round.direction)
                TRUE                        --X in correct range
                  SKIP
              --}}}
              Carry, Y := LONGDIFF (Xfrac[0], PowerTenFrac[(N + N) - 2], 0)
              Carry, Y := LONGDIFF (Xfrac[1], PowerTenFrac[(N + N) - 1], Carry)
              --{{{  
              IF
                (Xexp < PowerTenExp[N - 1]) OR ((Xexp = PowerTenExp[N - 1]) AND
                 (Carry <> 0))
                  SEQ                       --underflow power ten
                    Xexp := PowerTenExp[N - 1]
                    Xfrac[1] := PowerTenFrac[(N + N) - 1]
                    Xfrac[0] := PowerTenFrac[(N + N) - 2]
                    Round (Xexp, Xfrac, Xint, round.direction)
                    LogX := LogX - 1
                TRUE
                  SKIP
              --}}}
              --}}}
              WriteDec (Buf, Places, Xint)         --get number string
              --{{{  output the string in the correct format
              --{{{  fractional mode
              IF
                ( (Ip <> 0) AND (LogX < Ip) ) OR
                  ( (Dp = 0) AND (LogX < N ) AND
                    (((-max.no.of.zeroes.before.first.significant.digit) - 1) <= LogX) )
                  --{{{  try to output in mmm.nnnn form
                  SEQ
                    Y := (Dp + LogX) + 1         --current estimate at actual field width
                    IF
                      Y < 0                      --must ensure that Y >= 0
                        Y := 0
                      TRUE
                        SKIP
                    SEQ i = 0 FOR Places
                      Buf.1[i] := Buf[i]
                    Places.1 := Places
                    LogX.1 := LogX
                    IF
                      Dp <> 0
                        restrict (Buf.1, Places.1, LogX.1, Y, round.direction)
                      TRUE
                        SKIP
                    IF
                      ( (Ip <> 0) AND (LogX.1 < Ip) ) OR
                        ( (Dp = 0) AND (LogX.1 < N) AND
                          (((-max.no.of.zeroes.before.first.significant.digit) - 1) <= LogX.1) )
                        --{{{  output in mmm.nnnn form
                        SEQ
                          --{{{  set Scale
                          IF
                            LogX.1 < 0                   --always 0decimal.point
                              Scale := 1
                            TRUE
                              Scale := LogX.1 + 1
                          --}}}
                          --the value of Scale is the number of digits that there will be before the decimal.point
                          --{{{  pad with leading spaces to make up desired Ip
                          IF
                            Ip < Scale
                              SKIP
                            TRUE
                              SEQ i = 0 FOR Ip - Scale
                                put.byte (' ')
                          --}}}
                          N := Scale + Dp                --reduce remaining field width
                          --{{{  deal with sign
                          IF
                            (X[1] /\ SignBit) = 0        --positive sign
                              IF
                                Dp = 0                   --free format
                                  SKIP
                                TRUE
                                  put.byte (' ')
                            TRUE
                              put.byte ('-')
                          --}}}
                          --{{{  output 0decimal.point if number < 1
                          IF
                            LogX.1 < 0                   --less than 1
                              SEQ
                                put.byte ('0')
                                put.byte (decimal.point)
                                N := N - 1               -- 1 accounts for zero ( decimal.point is taken account of elsewhere )
                            TRUE
                              SKIP
                          --}}}
                          Scale := LogX.1 + 1            --check if < 0
                          --{{{  insert zeroes after decimal.point but before first significant digit ( if there is one )
                          IF
                            Dp = 0                           --free format
                              WHILE Scale < 0
                                SEQ
                                  put.byte ('0')
                                  Scale := Scale + 1
                            TRUE
                              WHILE ( Scale < 0 ) AND ( N > 0 )
                                SEQ
                                  put.byte ('0')
                                  Scale := Scale + 1
                                  N := N - 1                 --a digit has been output
                          --}}}
                          Scale := 0                     --places after point
                          IF
                            Dp <> 0
                              SKIP
                            TRUE
                              N := MaxDecN               --free format: use as many digits as possible
                          restrict (Buf.1, Places.1, LogX.1, N, round.direction)
                          --{{{  output significant digits and trailing zeroes
                          SEQ i = 0 FOR N                --number of valid digits
                            SEQ
                              IF
                                i < Places.1             --in buffer
                                  put.byte (Buf.1[i])
                                i <= (LogX.1 + 1)        --integer part (or 0 after point)
                                  put.byte ('0')
                                Dp > 0                   --use trailing zeroes; IEEE 5.6 says we can
                                  put.byte ('0')
                                TRUE
                                  SKIP
                              IF
                                i = LogX.1               --decimal point
                                  put.byte (decimal.point)
                                TRUE
                                  SKIP
                          --}}}
                          --{{{  deal with situation if ended with decimal point
                          IF
                            (LogX.1 + 1) = N             --ended with dec point
                              put.byte ('0')
                            TRUE
                              SKIP
                          --}}}
                          Places := 0                    --set flag: number already output
                        --}}}
                      TRUE
                        SKIP                     --has overflowed into exponential form
                  --}}}
                TRUE
                  SKIP
              --}}}
              --{{{  exponential - output sign and check forced exponential field width
              IF
                Places = 0                  --number already output
                  SKIP
                TRUE
                  --{{{  show sign and adjust field width for forced exponent
                  SEQ
                    --{{{  output sign
                    IF
                      (X[1] /\ SignBit) <> 0
                        put.byte ('-')
                      Dp <> 0
                        put.byte (' ')
                      TRUE
                        SKIP
                    --}}}
                    IF
                      Ip <> 0                        --exp form forced so make new mantissa width
                        --{{{  
                        SEQ
                          N := (Ip + Dp) - 4 --N is here the number of digits in exponential format;
                                             --total field width is number of digits(N) + 6, but this
                                             --must also equal Ip+Dp+2. Hence N must be Ip+Dp+2-6.
                          IF
                            N < 0
                              --{{{  display overflow
                              SEQ
                                put.byte ('O')
                                put.byte ('v')
                                SEQ i = 0 FOR (Ip + Dp) - 1      -- 3 chars of field already output
                                  put.byte (' ')
                                Places := 0                      --set finished flag
                              --}}}
                            TRUE
                              SEQ
                                IF
                                  N = 1
                                    put.byte (' ')   --fix when not enough space for any decimals
                                  N = 0
                                    N := 1           --ditto
                                  TRUE
                                    SKIP
                                restrict (Buf, Places, LogX, N, round.direction)
                        --}}}
                      TRUE
                        --{{{  set N
                        SEQ
                          N := Dp                    --free or fixed mantissa size exponent form
                          IF
                            N = 1
                              put.byte (' ')         --extra space to replace missing decimal.point
                            TRUE
                              SKIP
                        --}}}
                  --}}}
              --}}}
              --{{{  exponential form of output
              IF
                Places = 0                  --number already output
                  SKIP
                TRUE
                  --{{{  output in exponential form
                  SEQ
                    put.byte (Buf[0])
                    IF
                      N <> 1
                        put.byte (decimal.point)   --more digits to come so output the decimal.point
                      TRUE
                        SKIP
                    IF
                      N <> 0                       --exp form requested
                        SEQ
                          SEQ i = 1 FOR N - 1
                            IF
                              i < Places
                                put.byte (Buf[i])
                              i = 1                --only one digit
                                put.byte ('0')
                              TRUE                 --zero fill field
                                put.byte ('0')
                      Places <= 1                  --only one digit
                        put.byte ('0')
                      TRUE                         --output all digits
                        SEQ i = 1 FOR Places - 1
                          put.byte (Buf[i])
                    --{{{  E+/-ee
                    put.byte ('E')
                    IF
                      LogX < 0
                        SEQ
                          put.byte ('-')
                          LogX := -LogX
                      TRUE
                        put.byte ('+')
                    --now for the two digit exponent
                    put.byte (BYTE (((LogX / 10) \ 10) + (INT '0')))
                    put.byte (BYTE ((LogX \ 10) + (INT '0')))
                    --}}}
                  --}}}
              --}}}
              --}}}
            --}}}
        --}}}
  --}}}
:
