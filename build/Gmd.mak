#{{{  File banner
# @(#)=====================================================
# @(#)  Project : GPMIMD ESPRIT P5404
# @(#)  Authors : Mark Debbage, Mark Hill and Sean Wykes
# @(#)            University of Southampton
#  
# @(#)    Title : Makefile includes for source generated by GMD tools
# @(#)   System : occam 2 c
# @(#) Filename : Gmd.mak
# @(#)  Version : 1.9
# @(#)     Date : 1/14/94
# @(#)====================================================
#}}}

#{{{  
S=/
LFLAGS=-c -d -b -v
FULLAOPTS=-kwqtby
SRC=$(SPOC)$(S)source
TSRC=$(SRC)$(S)tables
GSRC=$(SRC)$(S)gmd
AST=$(GSRC)$(S)occam.ast $(GSRC)$(S)extend.ast
TREE=$(AST) $(GSRC)$(S)pretypechk.attr $(GSRC)$(S)typechk.attr $(GSRC)$(S)cstuff.attr $(GSRC)$(S)parusage.attr 
KEYWORDS=$(TSRC)$(S)Keywords $(TSRC)$(S)Keywords.ext $(TSRC)$(S)Keywords.udt $(TSRC)$(S)Keywords.ims
MODULES=CoutAg Cout Transform TypeChk TypeChkAg OccamOut ParUsageAg ParUsage Parser Tree TreeFix PreTypeChkAg
OTHERS=TokenDefs.h KeyTable.h

.KEEP_STATE:

#}}}
all:  $(MODULES:%=%.c) $(MODULES:%=%.h) $(OTHERS)


#{{{  VIEWS
occam.TS:       $(TREE) 
		echo VIEW occam SELECT Abstract Extend | cat - $(TREE) | cg -4
		echo TRAFO T TREE occam | puma -r > occam.P

extoccam.TS:       $(TREE) 
		echo VIEW extoccam SELECT Abstract Extend ParUsageTree | cat - $(TREE) | cg -4
		echo TRAFO T TREE extoccam | puma -r > extoccam.P
#}}}

#{{{  CoutAg MODULE
CoutAg.c: $(AST) $(GSRC)$(S)cstuff.attr $(GSRC)$(S)cstuff.ag
	cat $(AST) $(GSRC)$(S)cstuff.attr $(GSRC)$(S)cstuff.ag | cg -cAW


CoutAg.h:    CoutAg.c
#}}}
#{{{  Cout MODULE
Cout.c:         occam.TS $(GSRC)$(S)c.trafo Tree.c Transform.h
		puma -caf $(GSRC)$(S)c.trafo
		rm -f Cout.c.new
		cat Cout.c | sed "s/^static FILE[ -z]*yyf[ -z]*;/extern FILE \*yyf;/"  >Cout.c.new
		mv -f Cout.c.new Cout.c

Cout.h:         Cout.c
#}}}
#{{{  Transform MODULE
Transform.c:    occam.TS $(GSRC)$(S)trans.trafo Tree.c
		puma -ca $(GSRC)$(S)trans.trafo
		rm -f Transform.c.new
		cat Transform.c | sed "s/^static FILE[ -z]*yyf[ -z]*;/extern FILE \*yyf;/"  >Transform.c.new
		mv -f Transform.c.new Transform.c

Transform.h:    Transform.c
#}}}
#{{{  TypeChkAg MODULE
TypeChkAg.c:    $(AST) $(GSRC)$(S)typechk.ag TypeChk.h
		cat $(AST) $(GSRC)$(S)typechk.attr $(GSRC)$(S)typechk.ag| cg -cAW


TypeChkAg.h:    TypeChkAg.c 
#}}}
#{{{  PreTypeChkAg MODULE
PreTypeChkAg.c:    $(AST) $(GSRC)$(S)pretypechk.ag TypeChk.h 
		cat $(AST) $(GSRC)$(S)pretypechk.attr $(GSRC)$(S)pretypechk.ag| cg -cAW

TypeChkAg.h:    TypeChkAg.c 
#}}}
#{{{  TypeChk MODULE
TypeChk.c:      occam.TS $(GSRC)$(S)typechk.trafo
		puma -ca $(GSRC)$(S)typechk.trafo
		rm -f TypeChk.c.new
		cat TypeChk.c | sed "s/^static FILE[ -z]*yyf[ -z]*;/extern FILE \*yyf;/"  >TypeChk.c.new
		mv -f TypeChk.c.new TypeChk.c

TypeChk.h:	TypeChk.c
#}}}
#{{{  OccamOut MODULE
OccamOut.c:	occam.TS $(GSRC)$(S)occam.trafo Tree.c
		puma -ca $(GSRC)$(S)occam.trafo
		rm -f OccamOut.c.new
		cat OccamOut.c | sed "s/^static FILE[ -z]*yyf[ -z]*;/extern FILE \*yyf;/"  >OccamOut.c.new
		mv -f OccamOut.c.new OccamOut.c

OccamOut.h:       OccamOut.c

#}}}
#{{{  ParUsageAg MODULE
ParUsageAg.c:   $(AST) $(GSRC)$(S)parusage.attr $(GSRC)$(S)parusage.ag 
		cat $(AST) $(GSRC)$(S)parusage.attr $(GSRC)$(S)parusage.ag | cg -cAW


ParUsageAg.h:    ParUsageAg.c
#}}}
#{{{  ParUsage MODULE
ParUsage.c:	extoccam.TS $(GSRC)$(S)parusage.trafo Tree.c
		puma -ca $(GSRC)$(S)parusage.trafo
		rm -f ParUsage.c.new
		cat ParUsage.c | sed "s/^static FILE[ -z]*yyf[ -z]*;/extern FILE \*yyf;/"  >ParUsage.c.new
		mv -f ParUsage.c.new ParUsage.c

ParUsage.h:       ParUsage.c

#}}}
#{{{  Parser MODULE
occam.lalr:	$(GSRC)$(S)occam.bnf TokenDefs.h
		(sed "/^TOKEN/,999999d" $(GSRC)$(S)occam.bnf;echo "TOKEN"; sed <TokenDefs.h "s/#define *\([A-Z_0-9]*\) *\([0-9]*\)/  \1 = \2/"; sed "1,/^TOKEN/d" $(GSRC)$(S)occam.bnf)| sed s/NONE/kNONE/ >occam.lalr
						
Parser.c:       occam.lalr
		lalr $(LFLAGS) occam.lalr

Parser.h:	Parser.c

TokenDefs.h:	$(TSRC)$(S)Tokens $(KEYWORDS)
		cat $(TSRC)$(S)Tokens $(KEYWORDS) | grep -n . | sed "s/\([^:]*\):\(.*\)/#define \2 \1/" >TokenDefs.h

KeyTable.h:	$(TSRC)$(S)Tokens $(KEYWORDS)
		echo "#define NoTokens" `cat $(TSRC)$(S)Tokens | wc -l` >KeyTable.h
		echo "#define NoKeywords" `cat $(TSRC)$(S)Keywords $(TSRC)$(S)Keywords.ext | wc -l` >>KeyTable.h
		echo "#define NoKeywords_udt" `cat $(TSRC)$(S)Keywords.udt | wc -l` >>KeyTable.h
		echo "#define NoKeywords_ims" `cat $(TSRC)$(S)Keywords.ims | wc -l` >>KeyTable.h
		echo "struct KeyList KeyTable[] = " >>KeyTable.h 
		(echo "{"; cat $(KEYWORDS) | sort | sed "s/\(.*\)/  {\"\1\",\1},/") >>KeyTable.h 
		(echo "  {0,0}"; echo "};") >>KeyTable.h

#}}}
#{{{  Tree MODULE
Tree.c:         $(TREE)
		cat $(TREE) | cg -cmRdis $(FULLAOPTS) 
		rm -f Tree.c.new
		cat Tree.c | sed "s/^static FILE[ -z]*yyf[ -z]*;/extern FILE \*yyf;/"  >Tree.c.new
		mv -f Tree.c.new Tree.c

Tree.h:         Tree.c

#}}}
#{{{  TreeFix MODULE
TreeFix.c:	occam.TS $(GSRC)$(S)treefix.trafo
		puma -ca $(GSRC)$(S)treefix.trafo
		rm -f TreeFix.c.new
		cat TreeFix.c | sed "s/^static FILE[ -z]*yyf[ -z]*;/extern FILE \*yyf;/"  >TreeFix.c.new
		mv -f TreeFix.c.new TreeFix.c

TreeFix.h:	TreeFix.c
#}}}
